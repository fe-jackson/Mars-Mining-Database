================================================================================
========================================================= Overview and Objective 

For this assignment you will be writing a C++ program that makes use of STL
data structures and STL types. The program will read data from a file, store
the data in a "database", then generate reports from the data that is in the
database. There are two primary objectives of this assignment: explore using
good, object-oriented design, and use STL data structures (most likely maps
and vectors).

The data your program will be reading is production data generated by miners
(see background.txt for a story that provides the context). This production
data is in raw form. Your program will store this in a database and then after
all of the data is read in, it will generate two different reports from the
data. More details are in the sections below.

I have provided a file that contains the main function. Your final submission
of the program is required to use this file without modifcation. You are free
to modify the program during your own development. Just make sure that what
you turn in uses the originial, unmodified showreport.cpp file.

I have also provided a few datafiles and the expected output associated with
each of those data files. The output of your program for a given data file
should match the output file exactly. This includes punctuation and
whitespace. See ~mike.noel/classes/all/checking_output.txt for information on
how to check this.

For full credit on the assignment it is important to follow the information in
the rubric.txt document. This document explains how I will grade this
assignment. It points out what are the most important things to pay attention
to.

Also note that I will be compiling and running your program on the PCC linux
system. If your program fails to compile, crashes, or runs in an infinite loop
on the PCC linux system, you will automatically receive a 0 for the
assignment.

================================================================================
======================================================================== Details 

The main driver for your program is in the showreport.cpp file. You must use
this file as it is unmodified. The main function in this file reads data, one
line at a time, from the supplied data file. For each line, it parses out
specific fields then creates an "entry" object. It passes this entry object to
the production database to be added. Once the entire file has been read in and
each entry added to the database, the main function prints two different
reports. The first report prints a yearly report for a few years. The second
report prints a station-based report for each year.

Each line of data contains:
<year> <month> <day> <station> <resource> <amount>

For example:
2045	1	18	Chicago	magnesium	974

Month numbers start at 1 (that is, 1 is January). There are seven stations:
Boston, Kansas, Chicago, Alabama, Journey, Survivor, BonJovi. There are seven
resources: water, iron, sodium, potassium, chloride, magnesium, silicon. Even
though you know the list of stations and resources, your program should not
hardcode the number of stations or resources. See the "Data Driven" section
below.

The yearly report starts by printing the year then for each station it prints
a table with months along the top and resources as rows. For example:

*******2045*******

Station: Alabama

                Jan     Feb     Mar     Apr     May     Jun     Jul     Aug     Sep     Oct     Nov     Dec     Tot
chloride        677       0     691       0       0       0       0       0       0       0     243       0    1611
iron            187     422       0       0       0       0     605       0     597       0       0       0    1811
...<continued>....

The station report sums up all of the resources in a given year per
station. For example:

*******2045*******
               Alabama    BonJovi     Boston    Chicago    Journey     Kansas   Survivor
chloride          1611       1013        748        935        338       1591        510
iron              1811       4342       1300        862       2498         70         81
...<continued>....

For the exact format of the report output you should analyze the supplied
output files. 

You will need to create a class files for entry, productiondb, and
reporter. The class definitions need to be in appropriate header files and the
class implementations need to be in appropriate cpp files. You should infer
the required APIs for each of these classes by how they are used in the main
function.

Once you have the files you can compile your files with showreport.cpp as
follows:

g++ -o production showreport.cpp entry.cpp productiondb.cpp reporter.cpp

If you add more files (which you're allowed to do if you need them) then you
would need to add them to the compilation line.

Once you have a compiled program, you can run it using the provided data files
by passing the data file as an argument on the command line. For example, the
following runs the program with the smalltestdata.txt file.

./production smalltestdata.txt

When working on a program of this size, it is best to first create a working
version of the program with the major functionality stubbed out. Your first
step should be to create the required classes with the required methods and
have those methods do nothing. At that point you can compile and run the
program. Of course it will not create the correct output but you will have a
good base to start building on. After this, you can choose which part of the
program you want to work on first and then build it up incrementally.

Be sure to give yourself plenty of time to work on this assignment.

================================================================================
========================================================== Design Considerations

---------------------------------------------------------------- Object Oriented

It is important to notice how the main function uses objects. In particular,
it uses three object types: entry, productiondb, and reporter. It makes many
objects of the entry type but only a single productiondb and reporter
object. The entire program functionality can be described in terms of the
objects. This is what is meant by object-oriented design.

The productiondb is an abstraction for holding all of the collected production
data and the reporter is a class that can generate various reports from a
given database. Each entry represents a "chunk" of data.

--------------------------------------------------------------- Layered Software

You can think of the system like this:

        show_report.cpp         |      user interface layer
  ---------------------------   |      
          productiondb          |      business logic layer
  ---------------------------   |      
   classes to store the data    |      data storage layer

This diagram is meant to show a couple things. First, the code in
showreport.cpp just interacts with the productiondb class and that class
interacts with classes to store the data. The showreport.cpp code never
interacts directly with the data storage classes. The second thing that this
diagram shows is how the program is structured in layers.

The user interface layer is written to read data (from a file) and output data
(to the screen). The business logic layer is meant to handle any specific
rules about the data. For example, maybe there is supposed to be a validity
check to make sure that the data is correct before storing it. This would be
defined in the "business logic". The data storage layer deals with storing the
data.

These layers of software create a modular program. This makes it easy to
exchange any of these layers with an alternate implementation. For example,
the user interface layer could be replaced with a more sophisticated driver
that gives the user a menu to add more data or print specific reports for
specific years. As long as that new interface layer interacts with the same
APIs on productiondb and reporter, that new code could be written without
changing the other classes.

Although I don't show it here, the same logic applies to the use of the
reporter class.

-------------------------------------------------------------------- Data Driven

The program needs to be completely data-driven. What that means is that the
program cannot assume any station names, resource types, or years of
production. The productiondb class should be able to work no matter what data
is given to it (as long as it's the correct type). The reporter class should
be able to generate a report no matter what data the productiondb has stored
(as long as it's the right type).

Your design and implementation of the productiondb class itself will probably
require additional classes for organizing and managing the data. You have a
lot of liberty in how you want to do the organize this. My solution has 4
classes related to the production database:

- productiondb -- the main database class that contains a mapping of station
  name to stationdata.
- stationdata -- a class that holds all data for a station organized by
  year. For each year of data there is a yeardata object.
- yeardata -- a class that holds all data for a year broken down by
  months. This has an array of resourcecount objects, one per month.
- resourcecount -- a class that holds a mapping between resource and amount of
  that resource that has been seen so far.

This is not the only way to organize the data. You are welcome to create any
additional classes that you need as long as you don't hardcode any of the data
values into your program.

----------------------------------------------------------------- Loose Coupling

The productiondb and reporter classes need to be designed well and with as
loose a coupling as possible. This means that the productiondb should not make
any assumptions about the type of reporting that the reporter class will
generate. And likewise, the reporter class should not have any understanding
of how the productiondb class is organizing and storing data.

For example, the reporter will not have a list of stations. Instead, the
reporter class will need to ask the productiondb class for a list of
stations. That list should be returned as a new list (not something internal
to the productiondb) that the reporter can use for creating a report.

================================================================================
======================================================== Turnin and Extra Credit

You must use the "turnin" program to turn in your assignment. DO NOT USE D2L
TO TURN IN YOUR ASSIGNMENT. Assignments turned in using D2L will not be
counted. For information on using the "turnin" program see
~mike.noel/classes/all/turnin.txt for information on using the "turnin"
program.

IMPORTANT: If the program fails to compile, crashes, or hangs then the program
automatically gets a 0.

IMPORTANT: If the program fails to compile, crashes, or hangs then the program
automatically gets a 0.

IMPORTANT: If the program fails to compile, crashes, or hangs then the program
automatically gets a 0.

IMPORTANT: If the program fails to compile, crashes, or hangs then the program
automatically gets a 0.

IMPORTANT: If the program fails to compile, crashes, or hangs then the program
automatically gets a 0.

(I mentioned that five times on purpose because I don't want anyone to note
notice it.)

------------------------------------------------------------------- Extra Credit

You can earn 1 point of extra credit for this assignment by creating an
additional reporter class. The additional reporter class should be in a file
called alt_reporter.cpp. That class should support the printFullReport() and
printStationReport() methods. This reporter class should generate a different
style of report than the reporter required for the class. It should be
substatially different than the original reporter but it can do anything you
want.

I will exercise your new reporter by compiling your program with the
alt_reporter.cpp instead of the reporter.cpp.

The extra credit point will give you 1 extra point on this assignment only. It
will not allow you to exceed to maximum points for the assignment.
